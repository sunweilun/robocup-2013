#include "Robot.h"
#include "motor_uplayer.h"
#include "getPhoto.h"

Robot::Robot()
{
    worldMap.setParent(this);
    ptInit();
    motor_init();
    imgCounter = 0;
    worldMap.loadCamParms(CAM_PARMS_PATH);
    image = NULL;
<<<<<<< HEAD
    ballLocated = false;
    ownGoalLocated = false;
    oppGoalLocated = false;
    radar = false;
    setCoord(0,0,0);
}

void Robot::radarOn()
{
    radar = true;
    cvNamedWindow(RADAR_WND_NAME);
    cvMoveWindow(RADAR_WND_NAME,0,0);
}

void Robot::radarOff()
{
    radar = false;
    cvDestroyWindow(RADAR_WND_NAME);
=======
>>>>>>> 68a2afa6a3ed34fd9bae2467f4368db8e9fd6acc
}

void Robot::setCoord(float x,float y,float ori)
{
    this->x = x;
    this->y = y;
    this->ori = ori;
}

void Robot::turnLeft(float angle)
{
    ori -= angle*M_PI/180;
    ori = ori>2*M_PI?ori-2*M_PI:ori;
    ori = ori<0?ori+2*M_PI:ori;
    motor_turnLeft(angle*M_PI/180);
<<<<<<< HEAD
    updateRadar();
=======
>>>>>>> 68a2afa6a3ed34fd9bae2467f4368db8e9fd6acc
}

void Robot::turnRight(float angle)
{
    ori += angle*M_PI/180;
    ori = ori>2*M_PI?ori-2*M_PI:ori;
    ori = ori<0?ori+2*M_PI:ori;
    motor_turnRight(angle*M_PI/180);
<<<<<<< HEAD
    updateRadar();
=======
>>>>>>> 68a2afa6a3ed34fd9bae2467f4368db8e9fd6acc
}

void Robot::drawMap() {
    printf("drawmap in!\n");
<<<<<<< HEAD
    /*for(int i=0;i<12;i++)
    {
        printf("for in!\n");
        getImage();
        turnRight(30);
        worldMap.updateMap(image);
    }*/
    getImage();
    worldMap.updateMap(image);
    turnRight(180);
    getImage();
    worldMap.updateMap(image);
    moveForward(200,30);
    getImage();
    worldMap.updateMap(image);
=======
   //getImage();

    for(int i=0;i<12;i++)
    {
        printf("for in!\n");
        getImage();
        worldMap.updateMap(image);
        turnRight(30);
    }

    //getImage();
    //worldMap.updateMap(image);
    //turnRight(180);
    //getImage();
    //worldMap.updateMap(image);
    //moveForward(200,30);
    //getImage();
    worldMap.updateMap(image);
    worldMap.saveMap("result.png");
>>>>>>> 68a2afa6a3ed34fd9bae2467f4368db8e9fd6acc
}

void Robot::getImage()
{
<<<<<<< HEAD
    usleep(SLEEPTIME_BEFORE_PHOTO); // sleep until the camera is still
=======
    usleep(1000000);
>>>>>>> 68a2afa6a3ed34fd9bae2467f4368db8e9fd6acc
    getPhoto();
    char dp[] = DATA_PATH;
    char fn[1024];
    sprintf(fn,"%s%d.dat",dp,imgCounter);
    printf("file = %s\n", fn);
    if(image)
        cvReleaseImage(&image);
    image = loadDatImage(fn);
    imgCounter++;
}

void Robot::moveForward(float dist,float max_speed)
{
    x += dist*sin(ori);
    y += dist*cos(ori);
    goWithDistance(dist,max_speed);
<<<<<<< HEAD
    updateRadar();
}

void Robot::updateRadar()
{
    if(!radar)
        return;
    IplImage* wMap = worldMap.getMap();
    cvCircle(wMap,cvPoint(x,y),ROBOT_RADIUS,CV_RGB(0,0,0),-1);
    cvLine(wMap,cvPoint(x,y),cvPoint(x+ROBOT_RADIUS*sin(ori),y+ROBOT_RADIUS*cos(ori)),CV_RGB(0,255,255),3);
    if(ballLocated)
        cvCircle(wMap,cvPoint(x,y),BALL_RADIUS,CV_RGB(255,0,0),-1);
    cvShowImage(RADAR_WND_NAME,wMap);
    cvReleaseImage(&wMap);
}

bool Robot::locateBall()
{
    if(!image)
        return false;
    std::vector<cv::Point3f> circles = ip.extractCircles(image);
    if(circles.size()<=0)
    {
        return false;
    }
    ballLocated = true;
    cv::Point2f rCoord;
    rCoord = worldMap.coord_screen2robot(cv::Point2f(circles[0].x,circles[0].y+circles[0].z));
    ball_coord = worldMap.coord_robot2world(rCoord);
    updateRadar();
    return true;
}

void Robot::findBall()
{
    getImage();
    while(!locateBall())
    {
        turnRight(FIND_BALL_ANGLE);
        getImage();
    }
=======
>>>>>>> 68a2afa6a3ed34fd9bae2467f4368db8e9fd6acc
}

Robot::~Robot()
{
    if(image)
        cvReleaseImage(&image);
}
